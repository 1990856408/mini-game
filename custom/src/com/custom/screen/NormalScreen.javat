package com.mini.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.maps.MapLayer;
import com.badlogic.gdx.maps.MapObject;
import com.badlogic.gdx.maps.MapObjects;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
import com.badlogic.gdx.maps.tiled.TmxMapLoader;
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.*;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener;
import com.mini.member.MiniUserData;
import com.mini.constant.*;
import com.mini.game.MiniGame;
import com.mini.handle.GameScreenContactListener;
import com.mini.members.*;
import com.mini.members.status.ProtagonistStatus;
import com.mini.widget.ChunWidget;
import com.mini.xmembers.ChunLi;
import com.mini.xmembers.ChunLiQiGongBall;
import com.mini.xmembers.XGameSprite;

import java.util.Vector;

public class NormalScreen extends BaseScreen {
    //物理世界的数据部分
    @Deprecated
    public static final float WORLD_GRAVITY = 9.8f;//物理世界中重力的大小
    public static final int jump_max_count = 3;//最大连续跳跃数
    private static final float protaYforce = 300f;//主角弹跳受到的力
    private static final float protaXforce = 12f;//主角左右移动受到的力
    private static final float floor_friction = 0.4f;//地面的摩擦力
    /*
     * 图形相机此时的左下角视距的位置,与显示的范围,在updateCamera()中更新，
     * 这个用来决定某些音效何时播放，用来决定某个角色是否render也非常有效，
     * 可以很好的降低时间复杂度
     */
    public static float camera_pos_x;
    public static float camera_pos_y;
    public static long count = 0;
    //当前关卡需要多少得分才可以通关
    private final int MaxScore = MiniGame.currLevel * 50;
    public int currentScore = 0;//当前得分
    public Protagonist prota;//游戏主角
    public int jump = jump_max_count;//当前剩余连续跳跃数
    private World world;//物理世界
    private GameScreenContactListener conListener;//自定义的物理世界监听器
    private Box2DDebugRenderer box2DRender;//物理世界渲染器
    private OrthographicCamera box2DCamera;//物理世界相机
    private boolean Box2DDebug;//是否调试物理世界，这个用来决定是否更新物理世界的相机
    //地图的数据部分
    private TiledMap tileMap;//地图
    private float tileSize;//图块大小
    private float mapWidth;//地图横向图块个数
    private float mapHeight;//地图纵向图块个数
    private OrthogonalTiledMapRenderer mapRender;//地图渲染器，正交投影渲染器
    //动画渲染时间，游戏主角
    private float deltaTime;//游戏时间
    private Duck pduck;
    private Vector<Duck> ducks;//鸭子的集合
    private Dinosaur pDino;
    private Vector<Dinosaur> dinos;//恐龙的集合
    private Diamond egg;
    private Vector<Diamond> eggs;//蛋的集合
    private Robot robot;
    private Vector<Robot> robots;//机器人的集合
    private Hedgehog hedge;
    private Vector<Hedgehog> hedges;//刺猬的集合
    /*
     * 舞台，这里用了一个默认舞台，主要是辅助监听主角中的图片按钮
     */
    private Stage stage;
    //	private boolean up,down,left,right;//四个方位的按钮是否被按下，此标记用来实现长按效果
    private ButtonListener buLi;//按钮监听器
    /*
     * 用来实现不同功能所需要的变量
     */
    private Vector<Body> removeBodys;//这个刚体中存放的是所有需要移除的刚体
    private Vector<Body> harms;    //受到伤害的刚体

    //构造器中只初始化物理世界的东西，因为下面要用到
    public NormalScreen(MiniGame mainGame) {
        super(mainGame);

        this.world = new World(new Vector2(0f, -WORLD_GRAVITY), false);
        this.conListener = new GameScreenContactListener(this);
        this.world.setContactListener(conListener);
        this.box2DRender = new Box2DDebugRenderer();
        this.box2DCamera = new OrthographicCamera();
        this.box2DCamera.setToOrtho(false, MiniGameConfig.getScreenSettingViewW() / ConstantMembers.LENGTHRATE,
                MiniGameConfig.getScreenSettingViewH() / ConstantMembers.LENGTHRATE);
        this.Box2DDebug = true;

        this.deltaTime = 0;
    }

    /*
     *初始化函数，执行各项动作的初始化
     */
    public void init() {
        this.createMap();
        this.createProta();
        this.createDuck();
        this.createDino();
        this.createEgg();
        this.createRobot();
        this.createHedge();
        this.initStage();

        soundPlayer.playBackSound();
    }

    //创建地图的函数
    private void createMap() {
        this.tileMap = new TmxMapLoader().load("maps/game_screen" + MiniGame.currLevel + ".tmx");
        this.mapRender = new OrthogonalTiledMapRenderer(tileMap);
        this.tileSize = tileMap.getProperties().get("tilewidth", Integer.class);
        this.mapWidth = tileMap.getProperties().get("width", Integer.class);
        this.mapHeight = tileMap.getProperties().get("height", Integer.class);
        TiledMapTileLayer layer;
        layer = (TiledMapTileLayer) this.tileMap.getLayers().get("map");
        //在物理世界中创建地图中的刚体
        this.createMapLayer(layer);
        this.createMapBound();
    }

    //创建地图的边界
    private void createMapBound() {
        MiniUserData data = new MiniUserData();
        data.name = ConstantNames.EDGE;

        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyType.StaticBody;
        //边缘图形，说白了也就是一条线
        EdgeShape shape = new EdgeShape();
        shape.set(0, 0, (14 + mapWidth) * tileSize / ConstantMembers.LENGTHRATE, 0);
        EdgeShape shape2 = new EdgeShape();
        shape2.set(0, 0, 0, (14 + mapHeight) * tileSize / ConstantMembers.LENGTHRATE);

        FixtureDef fixTureDef = new FixtureDef();
        fixTureDef.filter.categoryBits = ConstantMembers.EDGE;
        fixTureDef.filter.maskBits = ConstantMembers._EDGE;
        fixTureDef.isSensor = false;

        //下方的夹具
        fixTureDef.shape = shape;
        bodyDef.position.set(0,
                -7 * tileSize / ConstantMembers.LENGTHRATE);
        Body body = world.createBody(bodyDef);
        Fixture fixture = body.createFixture(fixTureDef);

        data.body = body;
        data.fixture = fixture;
        body.setUserData(data);
        fixture.setUserData(data);

        //上方的夹具
        bodyDef.position.set(0,
                (mapHeight * tileSize + 7 * tileSize) / ConstantMembers.LENGTHRATE);
        body = world.createBody(bodyDef);
        fixture = body.createFixture(fixTureDef);

        data.body = body;
        data.fixture = fixture;
        body.setUserData(data);
        fixture.setUserData(data);

        //左方的夹具
        fixTureDef.shape = shape2;
        bodyDef.position.set(0,
                -7 * tileSize / ConstantMembers.LENGTHRATE);
        body = world.createBody(bodyDef);
        fixture = body.createFixture(fixTureDef);

        data.body = body;
        data.fixture = fixture;
        body.setUserData(data);
        fixture.setUserData(data);

        //右方的夹具
        bodyDef.position.set(mapWidth * tileSize / ConstantMembers.LENGTHRATE,
                -7 * tileSize / ConstantMembers.LENGTHRATE);
        body = world.createBody(bodyDef);
        fixture = body.createFixture(fixTureDef);

        data.body = body;
        data.fixture = fixture;
        body.setUserData(data);
        fixture.setUserData(data);

    }

    //创建图层中的刚体，这里用的是链式图形
    private void createMapLayer(TiledMapTileLayer layer) {
        BodyDef bodyDef = new BodyDef();
        FixtureDef fixTureDef = new FixtureDef();
        for (int row = 0; row < mapHeight; row++) {
            for (int col = 0; col < mapWidth; col++) {
                Cell cell = layer.getCell(col, row);
                if (cell == null || cell.getTile() == null) {
                    continue;
                }
                bodyDef.type = BodyType.StaticBody;
                bodyDef.position.set((col + 0.5f) * tileSize / ConstantMembers.LENGTHRATE,
                        (row + 0.5f) * tileSize / ConstantMembers.LENGTHRATE);
                ChainShape chanShape = new ChainShape();
                Vector2[] v = new Vector2[3];
                v[0] = new Vector2(-tileSize / 2 / ConstantMembers.LENGTHRATE,
                        -tileSize / 2 / ConstantMembers.LENGTHRATE);
                v[1] = new Vector2(-tileSize / 2 / ConstantMembers.LENGTHRATE,
                        tileSize / 2 / ConstantMembers.LENGTHRATE);
                v[2] = new Vector2(tileSize / 2 / ConstantMembers.LENGTHRATE,
                        tileSize / 2 / ConstantMembers.LENGTHRATE);
                chanShape.createChain(v);

                fixTureDef.friction = floor_friction;
                fixTureDef.shape = chanShape;
                fixTureDef.filter.categoryBits = ConstantMembers.MAPBODY;
                fixTureDef.filter.maskBits = ConstantMembers._MAPBODY;
                fixTureDef.isSensor = false;
                Body body = this.world.createBody(bodyDef);
                Fixture fixture = body.createFixture(fixTureDef);

                MiniUserData data = new MiniUserData();
                data.name = ConstantNames.FOOT;
                data.body = body;
                data.fixture = fixture;
                body.setUserData(data);
                fixture.setUserData(data);
            }
        }
    }

    //创建主角
    private void createProta() {
        //获取主角的出生点
        MapLayer layer = tileMap.getLayers().get("mario");
        MapObject mario = layer.getObjects().get("mario");
        float init_x = mario.getProperties().get("x", Float.class);
        float init_y = mario.getProperties().get("y", Float.class);

        //实例化主角
//        prota = new Protagonist(Protagonist.getCreateBody(init_x, init_y, world));
        MiniUserData data = (MiniUserData) prota.getBody().getUserData();
        data.mine = prota;
        data = (MiniUserData) data.fixture.getUserData();
        data.mine = prota;
    }

    private void createHedge() {
        this.hedges = new Vector<Hedgehog>();
        MapLayer layer = tileMap.getLayers().get("hedge");

        MapObjects objects = layer.getObjects();
        float init_x = 0;
        float init_y = 0;
        for (MapObject o : objects) {
            if (o.getName() != null && o.getName().equals("hedge")) {
                init_x = o.getProperties().get("x", Float.class);
                init_y = o.getProperties().get("y", Float.class);

                hedge = new Hedgehog(Hedgehog.getCreateBody(init_x, init_y, world));
                //将鸭子添加到鸭子集合中
                hedges.add(hedge);

                MiniUserData data = (MiniUserData) hedge.getBody().getUserData();
                data.mine = hedge;
                data = (MiniUserData) data.fixture.getUserData();
                data.mine = hedge;
            }
        }
    }

    //创建蛋
    private void createEgg() {
        this.eggs = new Vector<Diamond>();
        MapLayer layer = tileMap.getLayers().get("egg");

        MapObjects objects = layer.getObjects();
        float init_x = 0;
        float init_y = 0;
        for (MapObject o : objects) {
            if (o.getName() != null && o.getName().equals("egg")) {
                init_x = o.getProperties().get("x", Float.class);
                init_y = o.getProperties().get("y", Float.class);

//                egg = new Diamond(Diamond.getCreateBody(init_x, init_y, world));
                eggs.add(egg);

                MiniUserData data = (MiniUserData) egg.getBody().getUserData();
                data.mine = egg;
                data = (MiniUserData) data.fixture.getUserData();
                data.mine = egg;
            }
        }

    }

    //创建鸭子
    private void createDuck() {
        //先实例化鸭子集合
        this.ducks = new Vector<Duck>();
        //获取对象层
        MapLayer layer = tileMap.getLayers().get("duck");

        MapObjects objects = layer.getObjects();
        float init_x = 0;
        float init_y = 0;
        for (MapObject o : objects) {
            if (o.getName() != null && o.getName().equals("duck")) {
                init_x = o.getProperties().get("x", Float.class);
                init_y = o.getProperties().get("y", Float.class);

//                pduck = new Duck(Duck.getCreateBody(init_x, init_y, world));
                //将鸭子添加到鸭子集合中
                ducks.add(pduck);

                MiniUserData data = (MiniUserData) pduck.getBody().getUserData();
                data.mine = pduck;
                data = (MiniUserData) data.fixture.getUserData();
                data.mine = pduck;
            }
        }

    }

    //创建恐龙与创建鸭子类似，这里不做过多解释
    private void createDino() {
        //先实例化恐龙集合
        this.dinos = new Vector<Dinosaur>();
        //获取对象层
        MapLayer layer = tileMap.getLayers().get("dino");
        MapObjects objects = layer.getObjects();
        float init_x = 0;
        float init_y = 0;
        for (MapObject o : objects) {
            if (o.getName() != null && o.getName().equals("dino")) {
                init_x = o.getProperties().get("x", Float.class);
                init_y = o.getProperties().get("y", Float.class);
                pDino = new Dinosaur(Dinosaur.getCreateBody(init_x, init_y, world));
                //将恐龙添加到集合中
                dinos.add(pDino);

                MiniUserData data = (MiniUserData) pDino.getBody().getUserData();
                data.mine = pDino;
                data = (MiniUserData) data.fixture.getUserData();
                data.mine = pDino;
            }
        }
    }

    private void createRobot() {
        this.robots = new Vector<Robot>();
        //获取对象层
        MapLayer layer = tileMap.getLayers().get("robot");
        MapObjects objects = layer.getObjects();
        float init_x = 0;
        float init_y = 0;
        for (MapObject o : objects) {
            if (o.getName() != null && o.getName().equals("robot")) {
                init_x = o.getProperties().get("x", Float.class);
                init_y = o.getProperties().get("y", Float.class);
                robot = new Robot(Robot.getCreateBody(init_x, init_y, world));
                robots.add(robot);

                MiniUserData data = (MiniUserData) robot.getBody().getUserData();
                data.mine = robot;
                data = (MiniUserData) data.fixture.getUserData();
                data.mine = robot;
            }
        }
    }

    //创建舞台
    protected void initStage() {
//        //实例化舞台
//        stage = new Stage(new StretchViewport(ScreenSetting.VIEW_W, ScreenSetting.VIEW_H)
//                , batch);
//        //实例化舞台监听器
//        buLi = new ButtonListener();
//        //先为各个角色添加监听器
//
//        stage.addActor(prota.direction_pad);
//        //将演员添加到舞台中
//
//        stage.addActor(prota.bar_hp);
//        stage.addActor(prota.bar_mp);
//
////		stage.addActor(prota.label_hp);
//        stage.addActor(prota.image_hp);
////		stage.addActor(prota.label_mp);
//        stage.addActor(prota.image_mp);
//        stage.addActor(prota.image_score);
//        stage.addActor(prota.label_score);
//        stage.addActor(prota.label_num);
//        //使舞台获得输入焦点
//        Gdx.input.setInputProcessor(stage);
    }

    //父类中的函数，用来监听后台键盘按键
    public void handleInput() {
        //如果角色死亡，则不必响应事件
        if (!prota.isAlive)
            return;

        float velocity_y = prota.getBody().getLinearVelocity().y;
        float velocity_x = prota.getBody().getLinearVelocity().x;
        if (Gdx.input.isKeyJustPressed(Keys.K)) {
            this.handle_K(velocity_x, velocity_y);
        }
        if (Gdx.input.isKeyJustPressed(Keys.J)) {
            this.handle_J(velocity_x, velocity_y);
        }
        if (Gdx.input.isKeyJustPressed(Keys.P)) {
            this.handle_P(velocity_x, velocity_y);
        }
        if (Gdx.input.isKeyJustPressed(Keys.I)) {
            this.handle_I(velocity_x, velocity_y);
        }
        if (Gdx.input.isKeyJustPressed(Keys.W)) {
            this.handle_W(velocity_x, velocity_y);
        }
        if (Gdx.input.isKeyPressed(Keys.A)) {
            this.handle_A(velocity_x, velocity_y);
        }
        if (Gdx.input.isKeyPressed(Keys.D)) {
            this.handle_D(velocity_x, velocity_y);
        }
        if (Gdx.input.isKeyPressed(Keys.S)) {
            this.handle_S(velocity_x, velocity_y);
            //如果蹲下了，那么将设置为蹲下的夹具
            prota.updateFixture(true);
        } else {
            //如果没有任何按键被按下，那么将设置为没有蹲下的夹具
            prota.updateFixture(false);
            prota.state = ProtagonistStatus.QUIET;
        }
    }

    public void handleInputA() {
//        //如果角色死亡，则不必响应事件
//        if (!prota.isAlive)
//            return;
//
//        float velocity_y = prota.getBody().getLinearVelocity().y;
//        float velocity_x = prota.getBody().getLinearVelocity().x;
//        //处理摇杆的触摸
//        if (prota.direction_pad.isTouched()) {
//            //获取摇杆位置相对于中心的距离的百分比
//            float x = prota.direction_pad.getKnobPercentX();
//            float y = prota.direction_pad.getKnobPercentY();
//
//            float limits_y = Math.abs(x);
////			System.out.println(x+"\t"+y);
//            if (x > 0) {
//                if (y < limits_y && y > -limits_y)
//                    this.handle_D(velocity_x, velocity_y);
//                else if (y > 0)
//                    this.handle_W(velocity_x, velocity_y);
//                else if (y < 0) {
//                    this.handle_S(velocity_x, velocity_y);
//                    prota.updateFixture(true);
//                }
//            } else if (x < 0) {
//                if (y > -limits_y && y < limits_y)
//                    this.handle_A(velocity_x, velocity_y);
//                else if (y > 0)
//                    this.handle_W(velocity_x, velocity_y);
//                else if (y < 0) {
//                    this.handle_S(velocity_x, velocity_y);
//                    prota.updateFixture(true);
//                }
//            }
//        } else//如果摇杆没有被触碰,则设置状态为没有下蹲，设置为站立
//        {
//            prota.updateFixture(false);
//            prota.state = ProtagonistStatus.QUIET;
//        }
    }

    /*
     * 用来实现各个时间的具体小的函数
     */
    private void handle_K(float velocity_x, float velocity_y) {
        /*
         * 如果跳跃次数大于0，就使跳跃次数减1，并产生跳跃
         */
        if (jump > 0) {
            jump--;
            prota.getBody().setLinearVelocity(velocity_x, 0);
            prota.getBody().applyForceToCenter(0, protaYforce, true);
            soundPlayer.playSound(EnumSound.JUMP);
        }
    }

    //实现触摸跳跃，与按键跳跃略有不同
    private void handle_K2(float velocity_x, float velocity_y) {
        /*
         * 如果跳跃次数大于0，就产生跳跃
         */
        if (jump >= 1) {
            prota.getBody().setLinearVelocity(velocity_x, 0);
            prota.getBody().applyForceToCenter(0, protaYforce, true);
            soundPlayer.playSound(EnumSound.JUMP);
        }
    }

    private void handle_J(float velocity_x, float velocity_y) {
        prota.createBullet();
    }

    private void handle_W(float velocity_x, float velocity_y) {
        prota.superAttack();
    }

    private void handle_S(float velocity_x, float velocity_y) {
        if (velocity_y == 0 && conListener.isOnFoot()) {
            prota.state = ProtagonistStatus.SQUAT;
        }
    }

    private void handle_A(float velocity_x, float velocity_y) {
        prota.direction = 'A';
        prota.getBody().applyForceToCenter(-protaXforce, 0, true);
    }

    private void handle_D(float velocity_x, float velocity_y) {
        prota.direction = 'D';
        prota.getBody().applyForceToCenter(protaXforce, 0, true);
    }

    private void handle_I(float velocity_x, float velocity_y) {
        /*
         * 如果不在春丽状态，则创建春丽，如果成功的创建了春丽，则播放一个春丽横穿屏幕的效果
         */
        if (!prota.isChunli) {
            prota.createChunLi();
            if (prota.isChunli) {
                stage.addActor(new ChunWidget().image_widget);
            }
        }

    }

    private void handle_P(float velocity_x, float velocity_y) {
        if (prota.alive_fire) {
            prota.alive_fire = false;
        } else {
            soundPlayer.playSound(EnumSound.BURN);
            prota.alive_fire = true;
        }
    }

    //更新状态的函数
    @Override
    public void update() {
        this.updateProta();
        this.handleInput();
        this.updateFixtures();
        this.updateCharacters();
        this.updateScore();
        this.updateSuccessful();
        //清屏函数
        Gdx.gl.glClearColor(0, 0, 0, 0);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
    }

    //这里主要是更新了一下跳跃次数
    private void updateProta() {
        if (!prota.isAlive)
            return;

        float velocity_y = prota.getBody().getLinearVelocity().y;
        //若垂直速度为0，着地，并且没有在跳跃中，那么将当前跳跃速度设置为最大值
        if (velocity_y == 0 && conListener.isOnFoot() && prota.state != ProtagonistStatus.JUMP) {
            jump = jump_max_count;
        }
    }

    //用来更新物理世界中的角色
    private void updateCharacters() {
        //若主角死亡，则重新进入游戏场景
        if (!prota.isAlive) {
            soundPlayer.stopMusic();
            mainGame.initScreen = new InitialScreen(mainGame);
            mainGame.setScreen(mainGame.initScreen);
        }
        this.updateDionCharacters();
        this.updateDuckCharacters();
        this.updateEggCharacters();
        this.updateRobotCharacters();
        this.updateHedgeCharacters();

    }

    public void updateMonsterA(Vector<? extends GameSprite> ve, Class<? extends GameSprite> cl) {
        harms = conListener.getBulletHarmBodys();
        updateMonsterCharacters(ve, harms, ConstantHarms.BULLET_HARM);

        if (prota.chunli != null) {
            harms = conListener.getChunliHarmBodys();
            updateMonsterCharacters(ve, harms, ConstantHarms.CHUNLI_HARM, prota.chunli);
        }
        //处理气功掌的伤害
        if (prota.chunli != null && prota.chunli.qigong != null) {
            harms = conListener.getBallHarmBodys();
            updateMonsterCharacters(ve, harms, ConstantHarms.BALL_HARM, prota.chunli.qigong);
        }
        //根据怪物是否死亡来移除怪物的夹具
        updateMonsterFixture(ve, cl);
        //根据是否有夹具来决定是否移除刚体
        updateMonsterBody(ve, true);
    }

    /*
     * 第一个参数为可能受到伤害的集合，
     * 第二个参数为受到伤害的刚体的集合，
     * 第三个参数为伤害的值
     */
    public void updateMonsterCharacters(Vector<? extends GameSprite> suffer, Vector<Body> harm, float harm_value) {
        for (int i = 0; i < harm.size(); i++) {
            Body bu_harm = harm.get(i);
            for (int n = 0; n < suffer.size(); n++) {
                GameSprite gs = suffer.get(n);
                Body bo = gs.getBody();
                if (bu_harm.equals(bo)) {
                    gs.currentHP -= harm_value;
                    harm.remove(i);
                }
            }
        }
    }

    /*
     * 第一个参数为可能受到伤害的集合，
     * 第二个参数为受到伤害的刚体的集合，
     * 第三个参数为伤害的值
     * 第四个参数为产生伤害的对象，也就是伤害的产生者
     *
     * 这里暂时处理春丽的裂脚与气功掌，且二者区分依据为伤害值的大小，这不是一个好主意
     */
    public <T extends XGameSprite> void updateMonsterCharacters(Vector<? extends GameSprite> suffer, Vector<Body> harm, float harm_value, T p) {
        for (int i = 0; i < harm.size(); i++) {
            Body bu_harm = harm.get(i);
            for (int n = 0; n < suffer.size(); n++) {
                GameSprite gs = suffer.get(n);
                Body bo = gs.getBody();
                if (bu_harm.equals(bo)) {
                    float x = p.getBody().getPosition().x;
                    float y = p.getBody().getPosition().y;

                    float suffer_x = bo.getPosition().x;
                    float suffer_y = bo.getPosition().y;

                    if (harm_value == ConstantHarms.CHUNLI_HARM) {
                        if (p instanceof ChunLi) {
                            ChunLi chunli = (ChunLi) p;
                            if (chunli.isAttack) {
                                if (chunli.direction == 'D' && suffer_x > x) {
                                    gs.currentHP -= harm_value;
                                    bo.applyForceToCenter(ChunLi.force_Xleg, ChunLi.force_Yleg, true);
                                } else if (chunli.direction == 'A' && suffer_x < x) {
                                    gs.currentHP -= harm_value;
                                    bo.applyForceToCenter(-ChunLi.force_Xleg, ChunLi.force_Yleg, true);
                                }
                            } else {
                                if (chunli.direction == 'D' && x > suffer_x) {
                                    bo.applyForceToCenter(ChunLi.force_Xleg, 0, true);
                                } else if (chunli.direction == 'A' && x < suffer_x) {
                                    bo.applyForceToCenter(-ChunLi.force_Xleg, 0, true);
                                }
                            }
//							System.out.println(gs.currentHP);
                        }
                    } else if (harm_value == ConstantHarms.BALL_HARM) {
                        gs.currentHP -= harm_value;

                        bo.setLinearVelocity(0, 0);
                        if (suffer_x < x && suffer_y > y)
                            bo.applyForceToCenter(-ChunLiQiGongBall.xForce, ChunLiQiGongBall.yForce, true);
                        else if (suffer_x > x && suffer_y > y)
                            bo.applyForceToCenter(ChunLiQiGongBall.xForce, ChunLiQiGongBall.yForce, true);
                        else if (suffer_x < x && suffer_y < y)
                            bo.applyForceToCenter(-ChunLiQiGongBall.xForce, -ChunLiQiGongBall.yForce, true);
                        else if (suffer_x > x && suffer_y < y)
                            bo.applyForceToCenter(ChunLiQiGongBall.xForce, -ChunLiQiGongBall.yForce, true);

                    }
                    harm.remove(i);
                }
            }
        }
    }

    /*
     * 更新怪物的夹具，这里处理的怪物都是有生命值的怪物
     */
    public <T extends GameSprite> void updateMonsterFixture(Vector<? extends GameSprite> ve, Class<T> c) {
//		System.out.println(c.getSimpleName());
        for (int i = 0; i < ve.size(); i++) {
            GameSprite gs = ve.get(i);
            Body bo = gs.getBody();
            if (gs.isAlive)
                continue;
            if (bo.getFixtureList().size > 0) {
                bo.destroyFixture(bo.getFixtureList().first());
                switch (c.getSimpleName()) {
                    case "Dinosaur":
                        this.currentScore += ConstantValue.DION;
                        break;
                    case "Robot":
                        this.currentScore += ConstantValue.ROBOT;
                        break;
                    case "Hedgehog":
//					System.out.println("GG");
                        this.currentScore += ConstantValue.HEDGE;
                        break;
                }

            }
        }
    }

    /*
     * 处理怪物的刚体移除，那些死亡后会往下掉的怪物和static刚体
     * way=true;当怪物的纵坐标小于0的时候移除刚体
     * way=false;当失去夹具的时候移除刚体
     */
    public void updateMonsterBody(Vector<? extends GameSprite> ve, boolean way) {
        if (way) {
            for (int i = 0; i < ve.size(); i++) {
                GameSprite gs = ve.get(i);
                Body bo = gs.getBody();
                if (bo.getFixtureList().size == 0) {
                    gs.isAlive = false;
                    if (gs.getPox_y() < 0 && bo.getPosition().y < 0) {
                        if (!world.isLocked() && !gs.isRun) {
                            world.destroyBody(bo);
                            ve.remove(i);
                        }

                    }
                }
            }
        } else {
            for (int i = 0; i < ve.size(); i++) {
                GameSprite gs = ve.get(i);
                Body body = gs.getBody();
                if (body.getFixtureList().size == 0) {
                    gs.isAlive = false;
                    if (!world.isLocked() && !gs.isRun) {
                        world.destroyBody(body);
                        ve.remove(i);
                    }

                }
            }
        }
    }

    //更新机器球的集合，处理机器球受到的伤害
    private void updateRobotCharacters() {
        this.updateMonsterA(robots, Robot.class);
    }

    //恐龙集合的更新，更新恐龙受到的伤害
    private void updateDionCharacters() {
        this.updateMonsterA(dinos, Dinosaur.class);
    }

    //刺猬集合的更新，处理刺猬受到的伤害
    private void updateHedgeCharacters() {
        this.updateMonsterA(hedges, Hedgehog.class);
    }

    //鸭子集合的更新，处理鸭子受到的伤害
    private void updateDuckCharacters() {
        this.updateMonsterBody(ducks, true);
    }

    //蛋集合的更新，处理蛋受到的伤害
    private void updateEggCharacters() {
        this.updateMonsterBody(eggs, false);

    }

    private void updateSuccessful() {
        if (this.currentScore >= MaxScore) {
            if (MiniGame.currLevel == 5) {
                soundPlayer.stopMusic();
                mainGame.initScreen = new InitialScreen(mainGame);
                mainGame.setScreen(mainGame.initScreen);
                return;
            } else {
                MiniGame.currLevel++;
                soundPlayer.stopMusic();
                mainGame.transformScreen = new TransformScreen(mainGame);
                mainGame.setScreen(mainGame.transformScreen);
            }

        }
    }

    //用来更新标签中显示的分数
    private void updateScore() {
//        prota.label_num.setText(currentScore + "");
    }

    //用来移除物理世界中的刚体的夹具
    public void updateFixtures() {
        removeBodys = conListener.getRemoveBodys();
        //销毁所有刚体的夹具
        /*
         * 这里是如果移除夹具以后，再根据是否有夹具来判断其是否死亡
         */
        for (int i = 0; i < removeBodys.size(); i++) {
            Body bo = removeBodys.get(i);
            if (bo.getFixtureList().size > 0) {
                bo.destroyFixture(bo.getFixtureList().first());
                if (((MiniUserData) (bo.getUserData())).name.equals("duck"))
                    this.currentScore += ConstantValue.DUCK;
                if (((MiniUserData) (bo.getUserData())).name.equals("egg"))
                    this.currentScore += ConstantValue.EGG;
            }
        }
        removeBodys.clear();
    }

    //矫正图形世界相机位置
    private void adjustCamera() {
        if (camera.position.x < camera.viewportWidth / 2) {
            camera.position.x = camera.viewportWidth / 2;
        }
        if (camera.position.x > (mapWidth * tileSize - camera.viewportWidth / 2)) {
            camera.position.x = mapWidth * tileSize - camera.viewportWidth / 2;
        }
        if (camera.position.y < camera.viewportHeight / 2) {
            camera.position.y = camera.viewportHeight / 2;
        }
        if (camera.position.y > (mapHeight * tileSize - camera.viewportHeight / 2)) {
            camera.position.y = mapHeight * tileSize - camera.viewportHeight / 2;
        }

    }

    //矫正物理世界相机位置
    private void adjustBox2DCamera() {
        if (box2DCamera.position.x < box2DCamera.viewportWidth / 2) {
            box2DCamera.position.x = box2DCamera.viewportWidth / 2;
        }
        if (box2DCamera.position.x > (mapWidth * tileSize / ConstantMembers.LENGTHRATE - box2DCamera.viewportWidth / 2)) {
            box2DCamera.position.x = mapWidth * tileSize / ConstantMembers.LENGTHRATE - box2DCamera.viewportWidth / 2;
        }
        if (box2DCamera.position.y < box2DCamera.viewportHeight / 2) {
            box2DCamera.position.y = box2DCamera.viewportHeight / 2;
        }
        if (box2DCamera.position.y > (mapHeight * tileSize / ConstantMembers.LENGTHRATE - box2DCamera.viewportHeight / 2)) {
            box2DCamera.position.y = mapHeight * tileSize / ConstantMembers.LENGTHRATE - box2DCamera.viewportHeight / 2;
        }
    }

    //更新图形相机的位置
    private void updateCamera() {
        camera.position.set(prota.getPos_x() + MiniGameConfig.getScreenSettingViewW() / 4, prota.getPox_y() + MiniGameConfig.getScreenSettingViewH() / 8, 0);
        //矫正相机位置
        this.adjustCamera();
        camera.update();

        //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
        camera_pos_x = camera.position.x - MiniGameConfig.getScreenSettingViewW() / 2;
        camera_pos_y = camera.position.y - MiniGameConfig.getScreenSettingViewH() * 3 / 8;
        //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    }

    //更新物理相机的位置
    private void updateBox2DCamera() {
        if (Box2DDebug) {
            box2DCamera.position.set(prota.getPos_x() / ConstantMembers.LENGTHRATE + MiniGameConfig.getScreenSettingViewW() / ConstantMembers.LENGTHRATE / 4.0f,
                    prota.getPox_y() / ConstantMembers.LENGTHRATE + MiniGameConfig.getScreenSettingViewH() / ConstantMembers.LENGTHRATE / 8.0f, 0);
            //矫正物理世界相机的位置
            this.adjustBox2DCamera();
            box2DCamera.update();
        }
    }

    //渲染
    public void render(float delta) {
        count = 0;
        this.update();
        this.deltaTime += delta;//世界时间计时
        //地图渲染
        mapRender.setView(camera);
        mapRender.render();

        //相机更新
        this.updateCamera();
        batch.setProjectionMatrix(camera.combined);

        this.renderCharacters();

        stage.act();
        stage.draw();

        this.updateBox2DCamera();
        //物理世界时间步
//		box2DRender.render(world, box2DCamera.combined);
        world.step(ConstantMembers.WORLDTIME, 6, 2);
//		System.out.println(ducks.size()+"\t"+dinos.size()+"\t"+eggs.size()+"\t"+hedges.size()+
//				"\t:"+world.getBodyCount()+"\t"+world.getFixtureCount()+"\tCount"+count);
    }

    //渲染各个角色
    public void renderCharacters() {
        this.prota.render(batch, deltaTime);
        this.renderMonsterCharacter(ducks);
        this.renderMonsterCharacter(dinos);
        this.renderMonsterCharacter(robots);
        this.renderMonsterCharacter(eggs);
        this.renderMonsterCharacter(hedges);
    }

    public void renderMonsterCharacter(Vector<? extends GameSprite> ve) {
        for (GameSprite gs : ve) {
            gs.render(batch, deltaTime);
        }
    }

    @Override
    public void dispose() {
        if (world != null)
            world.dispose();
        if (box2DRender != null)
            box2DRender.dispose();
        if (tileMap != null)
            tileMap.dispose();
        if (mapRender != null)
            mapRender.dispose();
        if (stage != null)
            stage.dispose();
        if (prota != null)
            prota.dispose();
        if (soundPlayer != null)
            soundPlayer.dispose();
        this.monstersDispose(ducks);
        this.monstersDispose(dinos);
        this.monstersDispose(robots);
        this.monstersDispose(hedges);
        this.monstersDispose(eggs);
    }

    public void monstersDispose(Vector<? extends GameSprite> ve) {
        if (ve != null)
            for (GameSprite gs : ve)
                gs.dispose();
    }

    /*
     * 一个内部类，实现了手势监听接口，用来响应舞台中的各个事件
     */
    class ButtonListener extends ActorGestureListener {
        float velocity_y = prota.getBody().getLinearVelocity().y;
        float velocity_x = prota.getBody().getLinearVelocity().x;

        @Override
        public void touchDown(InputEvent event, float x, float y,
                              int pointer, int button) {
            //如果主角死亡，则不必响应触摸事件
            if (!prota.isAlive)
                return;
        }

        @Override
        public void touchUp(InputEvent event, float x, float y, int pointer,
                            int button) {
            if (!prota.isAlive)
                return;
            jump--;
        }
    }
}
